# <center>实验报告</center>
### <center>实验六	综合实验</center>
##### <p align="right">罗晏宸</br>PB17000297</br>2019.5.30</p>
***
## 实验目的  
1. **利用多周期CPU实现斐波那契数列的计算**  
    &emsp;&emsp;通过例化此前实验完成的多周期MIPS指令集CPU，并在存储器中初始化汇编指令的机器码，实现斐波那契数列的连续计算  
2. **连接外设并显示结果**  
    &emsp;&emsp;以VGA显示器作为外设，连接开发板与显示器，将数列计算结果以图像化的形式显示在屏上，理解并实践CPU、存储器与外设的连接方式   

***
## 实验内容  
### 1. 顶层模块
- **程序代码**  
    1. **<font face="consolas">Fibonacci_VGA.v</font>**
        ```verilog {'line-numbers}
        module Fibonacci_VGA #(parameter DIGIT = 32, ADDRWIDTH = 16)
        (CLK100MHZ, reset, f0, f1, continue, inc, dec, LED, AN, seg, VGA_R, VGA_G, VGA_B, VGA_HS, VGA_VS);
            input CLK100MHZ, reset;
            input [7 : 0] f0, f1;
            input continue;
            input inc, dec;
            output [15 : 0] LED; 
            output [ 7 : 0] AN;
            output [ 6 : 0] seg;
            output [ 3 : 0] VGA_R, VGA_G, VGA_B;
            output VGA_HS, VGA_VS;
            
            wire clock, CLK5MHZ;
            wire MemWrite;
            wire [ADDRWIDTH - 1 : 0] MemAddress;
            wire     [DIGIT - 1 : 0] MemData;
            wire     [DIGIT - 1 : 0] RegData;
            wire     [DIGIT - 1 : 0] ProbeMemData;
            wire [7 : 0] X, Y;
            reg [4 : 0] Count;
            wire [4 : 0] ProbeCount;
            wire [9 : 0] f;
            wire inc_s, dec_s;
            reg [4 : 0] increment;
            reg [4 : 0] decrement;
            FrequencyDivision  SecondPulse       (CLK5MHZ, 'b0, clock);
            MulticycleCPU       CPU (clock, reset, continue, MemData, , MemWrite, MemAddress, RegData, , );
            Memory              MEM (MemAddress[9 : 2], RegData, 8'b00000011, clock, MemWrite, MemData, ProbeMemData);
            Data_RAM            RAM  (Count, ProbeMemData, Y[7 : 3], CLK100MHZ, 'b1, f);
            VGADisplayUnit VDU (f << 2, CLK100MHZ, reset, X, Y, VGA_R, VGA_G, VGA_B, VGA_HS, VGA_VS);

            initial
            begin
                Count = 'b0;
                increment    = 'b0;
                decrement    = 'b0;
            end
            
            always @(ProbeMemData)
            begin
                Count <= Count + 'd1;
            end
            

            // Clock
            Clocking_Wizard_0  CLK100MHZ_to_5MHZ (CLK5MHZ, CLK100MHZ);

            
            // Address change
            Debounce           incStabilize      (CLK5MHZ, inc, inc_s);
            Debounce           decStabilize      (CLK5MHZ, dec, dec_s);
            assign ProbeCount = increment + decrement;
            
            always @(posedge inc_s or posedge reset)
            begin
                if (reset)
                    increment <= 'b0;
                else
                begin
                    if (inc_s)
                        increment <= increment + 'b1;
                end
            end	
            
            always @(posedge dec_s or posedge reset)
            begin
                if (reset)
                    decrement <= 'b0;
                else
                begin
                    if (dec_s)
                        decrement <= decrement - 'b1;
                end
            end	
        endmodule
        ```  
    2. **<font face="consolas">Debounce.v</font>**  
        ```verilog {.line-numbers}
        module Debounce(
            input clock,
            input button,
            output reg button_s
            );
            
            reg [20 : 0] count;
            reg count_enable;
            
            parameter LIMIT = 100_000; // 5MHz --> 20ms
            
            always @(posedge clock)
            begin
                if (count == LIMIT - 1)
                    button_s <= button;
            end
            
            always @(posedge clock)
            begin
                if (count_enable)
                    count <= count + 'b1;
                else
                    count <= 'b0;
            end
            
            always @(posedge clock)
            begin
                if (~count_enable && (button != button_s))
                    count_enable <= 1;
                else
                    if (count == LIMIT - 1)
                        count_enable <= 0;
            end
            
        endmodule
        ```
- **原理逻辑电路图**
    ![顶层模块原理](https://github.com/lyc0930/COD/blob/master/Fibonacci_VGA/Fibonacci_VGA_RTL.png?raw=true)
    **逻辑设计说明：**  
    >&emsp;&emsp;&emsp;&emsp;顶层模块通过连接CPU、存储器MEM、VGA显示数据VRAM以及VGA显示信号模块，实现CPU和外设两者与MEM的分别数据连接，CPU计算所得的数据存储于存储器中，通过显示缓存实现数据在VGA上的显示  
### 2. 多周期CPU  
- **程序代码**  
    1. **<font face="consolas">MIPS_opcode.vh</font>**
        ```verilog {.line-numbers}
        `define opcode    31 : 26
        `define rs        25 : 21
        `define rt        20 : 16

        `define rd        15 : 11
        `define shamt     10 : 6
        `define funct      5 : 0

        `define immediate 15 : 0

        `define address   25 : 0

        // Load 
        `define LB      6'b100000  // opcode
        `define LBU     6'b100100  // opcode
        `define LH      6'b100001  // opcode
        `define LHU     6'b100101  // opcode
        `define LW      6'b100011  // opcode

        // Save
        `define SB      6'b101000  // opcode
        `define SH      6'b101001  // opcode
        `define SW      6'b101011  // opcode


        `define R_type  6'b000000  // opcode
        // R-R Calculate
        `define ADD     6'b100000  // funct
        `define ADDU    6'b100001  // funct
        `define SUB     6'b100010  // funct
        `define SUBU    6'b100011  // funct
        `define MULT    6'b011000  // funct
        `define MULTU   6'b011001  // funct
        `define DIV     6'b011010  // funct
        `define DIVU    6'b011011  // funct
        `define SLT     6'b101010  // funct
        `define SLTU    6'b101011  // funct
        `define SLL     6'b000000  // funct
        `define SRL     6'b000010  // funct
        `define SRA     6'b000011  // funct
        `define SLLV    6'b000100  // funct
        `define SRLV    6'b000110  // funct
        `define SRAV    6'b000111  // funct
        `define AND     6'b100100  // funct
        `define OR      6'b100101  // funct
        `define XOR     6'b100110  // funct
        `define NOR     6'b100111  // funct

        // R-I Calculate
        `define ADDI    6'b001000  // opcode
        `define ADDIU   6'b001001  // opcode
        `define ANDI    6'b001100  // opcode
        `define ORI     6'b001101  // opcode
        `define XORI    6'b001110  // opcode
        `define LUI     6'b001111  // opcode
        `define SLTI    6'b001010  // opcode
        `define SLTIU   6'b001011  // opcode

        // Branch
        `define BEQ     6'b000100  // opcode
        `define BNE     6'b000101  // opcode
        `define BLEZ    6'b000110  // opcode
        `define BGTZ    6'b000111  // opcode
        `define BLTZ    6'b000001  // opcode | rt = 5'b00000
        `define BGEZ    6'b000001  // opcode | rt = 5'b00001

        // Jump
        `define J       6'b000010  // opcode
        `define JAL     6'b000011  // opcode
        `define JALR    6'b001001  // funct
        `define JR      6'b001000  // funct

        // Move
        `define MFHI    6'b010000  // funct
        `define MFLO    6'b010010  // funct
        `define MTHI    6'b010001  // funct
        `define MTLO    6'b010011  // funct

        // Privilege
        `define ERET    6'b011000  // funct | opcode = 6'b000010
        `define MFC0    5'b00000   // rs    | opcode = 6'b000010
        `define MTC0    5'b00100   // rs    | opcode = 6'b000010

        // Pitfall
        `define BREAK   6'b001101  // funct
        `define SYSCALL 6'b001100  // funct

        //NPCOp
        `define NPCOPB 0
        `define NPCOPJ 1
        ```
    2. **<font face="consolas">MultipleCPU.v</font>**
        ```verilog {.line-numbers}
        `include "MIPS_opcode.vh"
        module MulticycleCPU #(parameter DIGIT = 32, FIELDWIDTH = 5, ADDRWIDTH = 16, DEBUGSIZE = 8)
        (CLK, reset, run, MemData, ProbeAddress, MemWrite, MemAddress, RegReadData_1_RegOut, ProbePC, ProbeRegData);
            input CLK;
            input reset;
            input run;
            input      [DIGIT - 1 : 0] MemData;
            input  [DEBUGSIZE - 1 : 0] ProbeAddress;
            
            output MemWrite;
            output [ADDRWIDTH - 1 : 0] MemAddress;
            output     [DIGIT - 1 : 0] RegReadData_1_RegOut;
            output     [DIGIT - 1 : 0] ProbePC;
            output     [DIGIT - 1 : 0] ProbeRegData;
                
            // Control signal
            wire         PCWriteCondition_0;
            wire         PCWriteCondition_1;
            wire         PCWrite;
            wire         IorD;
            wire         MemtoReg;
            wire         IRWrite;
            wire [1 : 0] PCSource;
            wire [2 : 0] ALUOp;
            wire         ALUSrcA;
            wire [1 : 0] ALUSrcB;
            wire         RegWrite;
            wire         RegDst;
            wire [3 : 0] ALUControlSignal;
            
            // Wires
            wire      [DIGIT - 1 : 0] PCOut; 
            wire      [DIGIT - 1 : 0] Instruction;
            wire      [DIGIT - 1 : 0] MemData_RegOut;
            wire [FIELDWIDTH - 1 : 0] RegWriteAddress;
            wire      [DIGIT - 1 : 0] RegWriteData;
            wire      [DIGIT - 1 : 0] RegReadData_0, RegReadData_1;
            wire      [DIGIT - 1 : 0] RegReadData_0_RegOut;
            wire      [DIGIT - 1 : 0] ALUSource_A;
            wire      [DIGIT - 1 : 0] ALUSource_B;
            wire      [DIGIT - 1 : 0] Instruction_Extended;
            wire      [DIGIT - 1 : 0] ALUResult;
            wire              [3 : 0] ALUFlags;
            wire      [DIGIT - 1 : 0] ALUOut;
            wire      [DIGIT - 1 : 0] NextPC;
            
            
            // Debug
            wire clock;
            
            assign ProbePC = PCOut;
            assign clock = run & CLK;
            
            // Connection
            ControlUnit      	              CU                       (clock, reset, Instruction[`opcode], PCWriteCondition_0, PCWriteCondition_1, PCWrite, IorD, MemWrite, MemtoReg, IRWrite, PCSource, ALUOp, ALUSrcA, ALUSrcB, RegWrite, RegDst);
            ProgramCounter                    PC                       (clock, reset, NextPC, ((ALUFlags[0] & PCWriteCondition_0) | (~ALUFlags[0] & PCWriteCondition_1) | PCWrite), PCOut);
            Multiplexer  #(2, DIGIT)          MUX_MemAddress           (PCOut, ALUOut, , , IorD, MemAddress);
            InstructionRegister   			  IR                       (clock, IRWrite, MemData, Instruction);
            Register                          MDR                      (clock, MemData, MemData_RegOut);
            Multiplexer  #(2, FIELDWIDTH)     MUX_RegisterWriteAddress (Instruction[`rt], Instruction[`rd], , , RegDst, RegWriteAddress);
            Multiplexer  #(2, DIGIT)          MUX_RegisterWriteData    (ALUOut, MemData_RegOut, , , MemtoReg, RegWriteData);
            RegisterFile #(FIELDWIDTH, DIGIT) DR                       (clock, reset, Instruction[`rs], Instruction[`rt], ProbeAddress, RegWriteAddress, RegWriteData, RegWrite, RegReadData_0, RegReadData_1, ProbeRegData);
            SignExtend			              IEX                      (Instruction[15 : 0], Instruction_Extended);
            Register                          A                        (clock, RegReadData_0, RegReadData_0_RegOut);
            Register                          B                        (clock, RegReadData_1, RegReadData_1_RegOut);
            Multiplexer  #(2, DIGIT)          MUX_ALUSourceA           (PCOut, RegReadData_0_RegOut, , , ALUSrcA, ALUSource_A);
            Multiplexer  #(4, DIGIT)          MUX_ALUSourceB           (RegReadData_1_RegOut, 'd4, Instruction_Extended, (Instruction_Extended << 2), ALUSrcB, ALUSource_B);
            ALUControl		                  ALUCTRL                  (Instruction[`funct], ALUOp, ALUControlSignal);
            ALU	                              ALU                      (ALUControlSignal, ALUSource_A, ALUSource_B, ALUResult, ALUFlags);
            Register                          ALUOUT                   (clock, ALUResult, ALUOut);
            Multiplexer  #(3, DIGIT)          MUX_NextPC               (ALUResult, ALUOut, {PCOut[31 : 28], Instruction[25 : 0], 2'b00}, , PCSource, NextPC);

        endmodule
        ```
    3. **<font face="consolas">MUX.v</font>**
        ```verilog {.line-numbers}
        module Multiplexer #(parameter N = 2, DATASIZE = 32)(in_0, in_1, in_2, in_3, s, out);
            input      [DATASIZE - 1 : 0] in_0, in_1, in_2, in_3;
            input                 [1 : 0] s;
            
            output reg [DATASIZE - 1 : 0] out;

            initial
            begin
                out = 'b0;
            end
            
            always @(*)
            begin
                if (s >= N)
                    out = 'b0;
                else
                    case (s)
                        2'b00: out = in_0;
                        2'b01: out = in_1; 
                        2'b10: out = in_2; 
                        2'b11: out = in_3; 
                        2'bx0: out = in_0; 
                        2'bx1: out = in_1;
                        2'bz0: out = in_0; 
                        2'bz1: out = in_1;
                        default: 
                            out = 'b1111; 
                    endcase
                end

        endmodule
        ```
    4. **<font face="consolas">ControlUnit.v</font>**
        ```verilog {.line-numbers}
        `include "MIPS_opcode.vh"

        module ControlUnit(clock, reset, opcode, PCWriteCondition_0, PCWriteCondition_1, PCWrite, IorD, MemWrite, 
        MemtoReg, IRWrite, PCSource, ALUOp, ALUSrcA, ALUSrcB, RegWrite, RegDst);
            input clock;
            input reset;
            input      [5 : 0] opcode;

            output reg PCWriteCondition_0;
            output reg PCWriteCondition_1;
            output reg PCWrite;
            output reg IorD;
        //  output reg MemRead;
            output reg MemWrite;
            output reg MemtoReg;
            output reg IRWrite;
            output reg [1 : 0] PCSource;
            output reg [2 : 0] ALUOp;
            output reg ALUSrcA;
            output reg [1 : 0] ALUSrcB;
            output reg RegWrite;
            output reg RegDst;
            
            // State
            reg [16 : 0] CurrentState, NextState;
            parameter Idle                 = 17'b0,
                    InstructionFetch     = 1 <<  0,
                    InstructionDecode    = 1 <<  1,
                    MemoryAddressCompute = 1 <<  2,
                    MemoryAccess_LW      = 1 <<  3,
                    MemoryReadComplete   = 1 <<  4,
                    MemoryAccess_SW      = 1 <<  5,
                    RTypeExecution       = 1 <<  6,
                    RTypeComplete        = 1 <<  7,
                    ADDIExecution        = 1 <<  8,
                    ANDIExecution        = 1 <<  9,
                    ORIExecution         = 1 << 10,
                    XORIExecution        = 1 << 11,
                    SLTIExecution        = 1 << 12,
                    ITypeComplete        = 1 << 13,
                    BEQComplete          = 1 << 14,
                    BNEComplete          = 1 << 15,
                    JumpComplete         = 1 << 16;
            
            initial
            begin
                CurrentState       = Idle;
                PCWriteCondition_0 = 0;
                PCWriteCondition_1 = 0;
                PCWrite 	       = 0;
                IorD 		       = 0;
                MemWrite 	       = 0;
                MemtoReg 	       = 0;
                IRWrite 	       = 0;
                PCSource 	       = 2'b00;
                ALUOp 		       = 3'b000;
                ALUSrcA 	       = 0;
                ALUSrcB 	       = 2'b00;
                RegWrite 	       = 0;
                RegDst 		       = 0;
            end
            
            always @(posedge clock or posedge reset)
            begin
                if (reset)
                    CurrentState <= Idle;
                else
                    CurrentState <= NextState;
            end
            
            always @(*)
            begin
                case (CurrentState)
                
                    Idle:
                    begin
                        NextState = InstructionFetch;
                    end
                
                    InstructionFetch: 
                    begin
                        NextState = InstructionDecode;
                    end
                    
                    InstructionDecode: 
                    begin				
                        case (opcode)
                            `LW: 
                                NextState = MemoryAddressCompute;
                            `SW: 
                                NextState = MemoryAddressCompute;
                            `R_type: 
                                NextState = RTypeExecution;
                            `ADDI:
                                NextState = ADDIExecution; 
                            `ANDI: 
                                NextState = ANDIExecution;
                            `ORI:  
                                NextState = ORIExecution;
                            `XORI: 
                                NextState = XORIExecution;
                            `SLTI: 
                                NextState = SLTIExecution;
                            `BEQ: 
                                NextState = BEQComplete;
                            `BNE: 
                                NextState = BNEComplete;
                            `J: 
                                NextState = JumpComplete;
                            default : 
                                NextState = InstructionFetch;
                        endcase
                    end
                    
                    MemoryAddressCompute: 
                    begin				
                        case (opcode)
                            `LW:
                                NextState = MemoryAccess_LW;
                            `SW: 
                                NextState = MemoryAccess_SW;
                            default : 
                                NextState = InstructionFetch;
                        endcase
                    end
                    
                    MemoryAccess_LW: 
                    begin
                        NextState = MemoryReadComplete;
                    end
                    
                    MemoryReadComplete: 
                    begin
                        NextState = InstructionFetch;
                    end
                    
                    MemoryAccess_SW: 
                    begin
                        NextState = InstructionFetch;
                    end
                        
                    RTypeExecution: 
                    begin
                        NextState = RTypeComplete;
                    end
                    
                    RTypeComplete: 
                    begin
                        NextState = InstructionFetch;
                    end
                    
                    ADDIExecution: 
                    begin
                        NextState = ITypeComplete;
                    end
                    
                    ANDIExecution: 
                    begin
                        NextState = ITypeComplete;
                    end
                    
                    ORIExecution: 
                    begin
                        NextState = ITypeComplete;
                    end
                    
                    XORIExecution: 
                    begin
                        NextState = ITypeComplete;
                    end
                    
                    SLTIExecution: 
                    begin
                        NextState = ITypeComplete;
                    end
                    
                    ITypeComplete: 
                    begin
                        NextState = InstructionFetch;
                    end
                    
                    BEQComplete: 
                    begin
                        NextState = InstructionFetch;
                    end
                    
                    BNEComplete: 
                    begin
                        NextState = InstructionFetch;
                    end
                    
                    JumpComplete: 
                    begin
                        NextState = InstructionFetch;
                    end
                    
                    default :
                        NextState = InstructionFetch;
                endcase 
            end
            
            always @(posedge clock or posedge reset)
            begin
                if (reset)
                begin
                    PCWriteCondition_0 <= 0;
                    PCWriteCondition_1 <= 0;
                    PCWrite 	       <= 0;
                    IorD 		       <= 0;
                    MemWrite 	       <= 0;
                    MemtoReg 	       <= 0;
                    IRWrite 	       <= 0;
                    PCSource 	       <= 2'b00;
                    ALUOp 		       <= 3'b000;
                    ALUSrcA 	       <= 0;
                    ALUSrcB 	       <= 2'b00;
                    RegWrite 	       <= 0;
                    RegDst 		       <= 0;
                end
                else
                begin
                    case (NextState)
                        Idle:
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        InstructionFetch: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                                PCWrite 	       <= 1;
                                IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                                IRWrite 	       <= 1;
                                PCSource           <= 2'b00;
                                ALUOp 		       <= 3'b000;
                                ALUSrcA 	       <= 0;
                                ALUSrcB 	       <= 2'b01;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        InstructionDecode: 
                        begin				
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp 		       <= 3'b000;
                                ALUSrcA 	       <= 0;
                                ALUSrcB 	       <= 2'b11;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        MemoryAddressCompute: 
                        begin				
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp 		       <= 3'b000;
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b10;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        MemoryAccess_LW: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                                IorD               <= 1;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        MemoryReadComplete: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                                MemtoReg 	       <= 1;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                                RegWrite 	       <= 1;
                                RegDst 		       <= 0;
                        end
                        
                        MemoryAccess_SW: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                                IorD 		       <= 1;
                                MemWrite 	       <= 1;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                            
                        RTypeExecution: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp 		       <= 3'b010;
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        RTypeComplete: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                                MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                                RegWrite 	       <= 1;
                                RegDst 		       <= 1;
                        end
                        
                        ADDIExecution: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp              <= 3'b011; 
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b10;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        ANDIExecution: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp              <= 3'b100; 
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b10;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        ORIExecution: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp              <= 3'b101; 
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b10;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        XORIExecution: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp              <= 3'b110; 
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b10;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        SLTIExecution: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp              <= 3'b111; 
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b10;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        ITypeComplete: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                                MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                                RegWrite 	       <= 1;
                                RegDst 		       <= 0;
                        end
                        
                        BEQComplete: 
                        begin
                                PCWriteCondition_0 <= 1;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                                PCSource 	       <= 2'b01;
                                ALUOp 		       <= 3'b001;
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        BNEComplete: 
                        begin
                            PCWriteCondition_0 <= 0;
                                PCWriteCondition_1 <= 1;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                                PCSource 	       <= 2'b01;
                                ALUOp 		       <= 3'b001;
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        JumpComplete: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                                PCWrite 	       <= 1;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                                PCSource 	       <= 2'b10;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        default :
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                    endcase 
                end 
            end
            
        endmodule
        ```
    5. **<font face="consolas">InstructionRegister.v</font>**
        ```verilog {.line-numbers}
        module InstructionRegister #(parameter DIGIT = 32)
        (clock, IRWrite, MemData, Instruction);
            input clock; 
            input IRWrite; 
            input      [DIGIT - 1 : 0] MemData; 
            
            output reg [DIGIT - 1 : 0] Instruction;
            
            reg [31:0] Register;
            
            initial 
            begin
                Register    = 'b0;
                Instruction = 'b0;
            end
            
            always @(negedge clock) 
            begin
                if (IRWrite)
                    Register <= MemData;
                else
                    Register <= Register;
            end
            
            always @(posedge clock) 
            begin
                Instruction <= Register;
            end
            
        endmodule
        ```
    6. **<font face="consolas">Register.v</font>**
        ```verilog {.line-numbers}
        module Register #(parameter DIGIT = 32)(clock, In, Out);
            input clock;
            input      [31:0] In;
            
            output reg [31:0] Out;
            
            reg [31:0] Register;

            initial 
            begin
                Out      = 'b0;
                Register = 'b0;
            end
            
            always@(negedge clock) 
            begin
                Register <= In;
            end
            
            always@(posedge clock) 
            begin
                Out <= Register;
            end 
        
        endmodule
        ```
    7. **<font face="consolas">RegisterFile.v</font>**
        ```verilog {.line-numbers}
        module RegisterFile #(parameter REGSIZE = 5, DIGIT = 32)
        (clock, reset, Read_Address_0, Read_Address_1, Read_Address_2, Write_Address, Write_Data, 
        Write_Enable, Read_Data_0, Read_Data_1, Read_Data_2);
            input clock, reset;
            input Write_Enable;
            input  [REGSIZE - 1 : 0] Read_Address_0, Read_Address_1, Read_Address_2;
            input  [REGSIZE - 1 : 0] Write_Address;
            input    [DIGIT - 1 : 0] Write_Data;
            
            output   [DIGIT - 1 : 0] Read_Data_0, Read_Data_1, Read_Data_2;
            
            reg [DIGIT - 1 : 0] Register [1 : (1 << REGSIZE) - 1];
            integer i;
            
            assign Read_Data_0 = (Read_Address_0 == 0) ? 'b0 : (((Read_Address_0 == Write_Address) && Write_Enable) ? Write_Data : Register[Read_Address_0]);
            assign Read_Data_1 = (Read_Address_1 == 0) ? 'b0 : (((Read_Address_1 == Write_Address) && Write_Enable) ? Write_Data : Register[Read_Address_1]);
            assign Read_Data_2 = (Read_Address_2 == 0) ? 'b0 : (((Read_Address_2 == Write_Address) && Write_Enable) ? Write_Data : Register[Read_Address_2]);
            
            initial
            begin
                for (i = 1; i < DIGIT; i = i + 1)
                    Register[i] = 'b0;
            end
            
            always  @(posedge clock or posedge reset)
            begin
                if (reset)
                begin
                    for (i = 1; i < DIGIT; i = i + 1)
                        Register[i] <= 0;
                end
                else
                begin
                    if ((Write_Address != 0) && Write_Enable)
                        Register[Write_Address] <= Write_Data;
                end
            end
        endmodule
        ```
    8. **<font face="consolas">ALU.v</font>**
        ```verilog {.line-numbers}
        module ALU #(parameter  DIGIT = 32, CTRLSIZE = 4, FLAGSIZE = 4)(Control, A, B, Out, Flags);
            input  wire [CTRLSIZE - 1 : 0] Control;
            input  wire    [DIGIT - 1 : 0] A;
            input  wire    [DIGIT - 1 : 0] B;
            
            output  reg    [DIGIT - 1 : 0] Out;
            output wire [FLAGSIZE - 1 : 0] Flags;

            wire Carry_Borrow, Negative, Overflow, Zero;
            wire Carry, Borrow;
            wire [DIGIT - 1 : 0] add_sum, minus_sum;

            always @(*)
            begin
                case (Control)
                    4'b0000: Out = A + B;
                    4'b0001: Out = A + (~B + 'b1);//(F == 1) ? (('b1 << 6) - minus_sum) : minus_sum;
                    4'b1000: Out = A & B;
                    4'b1001: Out = A | B;
                    4'b1010: Out = ~A;
                    4'b1011: Out = ~(A | B);
                    4'b1100: Out = A ^ B;
                    4'b1101: Out = (A < B) ? 'b1 : 'b0;
                    default: 
                        Out = 'b0;
                endcase 
            end

            assign Flags               = {Carry_Borrow, Negative, Overflow, Zero};
            assign Carry_Borrow        = ~Control[CTRLSIZE - 1] && ((Control[0] == 0) ? Carry : Borrow);
            assign {Carry, add_sum}    = A + B;
            assign {Borrow, minus_sum} = A - B;	
            assign Negative            = ~Control[CTRLSIZE - 1] && (Overflow ^ Out[DIGIT - 1]);
            assign Overflow            = ~Control[CTRLSIZE - 1] && ((Control[0] ^~ (A[DIGIT - 1] ^ B[DIGIT - 1])) && (A[DIGIT - 1] ^ Out[DIGIT - 1]));
            assign Zero                = (Out == 'b0);

        endmodule
        ```
    9. **<font face="consolas">ALUControl.v</font>**
        ```verilog {.line-numbers}
        `include "MIPS_opcode.vh"

        module ALUControl #(parameter CTRLSIZE = 4)(funct, Operation, Signal);
            input                 [5 : 0] funct;
            input                 [2 : 0] Operation;
            
            output reg [CTRLSIZE - 1 : 0] Signal;
            
            initial
            begin
                Signal = 4'b0000;
            end
            
            always @(*)
            begin
                case (Operation)
                    3'b000: Signal = 4'b0000; // LW SW --> ADD
                    3'b001: Signal = 4'b0001; // BEQ --> SUB
                    3'b010: 
                        case (funct)
                            `ADD: Signal = 4'b0000; // ADD
                            `SUB: Signal = 4'b0001; // SUB
                            `AND: Signal = 4'b1000; // AND
                            `OR : Signal = 4'b1001; //  OR
                            `XOR: Signal = 4'b1100; // XOR
                            `NOR: Signal = 4'b1011; // NOR
                            `SLT: Signal = 4'b1101; // SLT
                            default:
                                Signal = 4'b0000;
                        endcase
                    3'b011: Signal = 4'b0000; // ADDI --> ADD
                    3'b100: Signal = 4'b1000; // ANDI --> AND
                    3'b101: Signal = 4'b1001; //  ORI -->  OR
                    3'b110: Signal = 4'b1100; // XORI --> XOR
                    3'b111: Signal = 4'b1101; // SLTI --> SLT
                    default:
                        Signal = 4'b0000;
                endcase 
            end
        endmodule
        ```
    10. **<font face="consolas">Extend.v</font>**
        ```verilog {.line-numbers}
        module SignExtend #(parameter INDIGIT = 16,OUTDIGIT = 32)(In, Out);
            input  [ INDIGIT - 1 : 0] In;
            output [OUTDIGIT - 1 : 0] Out;
            
            assign Out = {{OUTDIGIT - INDIGIT{In[INDIGIT - 1]}}, In};
        endmodule

        module ZeroExtend #(parameter INDIGIT = 16,OUTDIGIT = 32)(In, Out);
            input  [ INDIGIT - 1 : 0] In;
            output [OUTDIGIT - 1 : 0] Out;
            
            assign Out = {{OUTDIGIT - INDIGIT{1'b0}}, In};
        endmodule
        ```
- **原理逻辑电路图**  
    ![多周期CPU状态图](https://github.com/lyc0930/COD/blob/master/MulticycleCPU/%E7%8A%B6%E6%80%81%E5%9B%BE.png?raw=true)  
    ![多周期CPU原理](https://github.com/lyc0930/COD/blob/master/MulticycleCPU/CPU_RTL.png?raw=true)  
    **逻辑设计说明：**  
    >&emsp;&emsp;&emsp;&emsp;多周期CPU模块`MultipleCPU`通过组合连接各功能单元与多选器`Multiplexer`、寄存器`Register`等，在嵌有状态机的控制单元`ControlUnit`输出的各个控制信号下完成各指令的多周期实现  
    >&emsp;&emsp;&emsp;&emsp;如依据本次实验中所实现的指令子集重绘的状态图所示，共有18个不同的状态，不同颜色对不同类型指令执行的状态转移做了区分，并以背景中的三个同心圆显示各指令类型需要的时间周期数————3～5不等。  
- **汇编代码 <font face="consolas">inst_rom.S</font>**  
    ```mipsasm
    j _loop

    .data
        .word 1,1,6   #编译成机器码时编译器会在前面多加个0，所以后面lw指令地址会多加4

    _loop:    
            addi $t0,$0,6
            lw   $t1,16($0) #通过更改$3的值控制运行
            lw   $s0,8($0)
            lw   $s1,12($0)
            add  $s2,$s1,$s0 
            sw   $s1,8($0)
            sw   $s2,12($0) #最新结果存在$1里
    _hold:
            beq  $t0,$t1,_next
            j    _hold
    _next:
            j    _loop
    ```  
- **存储器初始化文件 <font face="consolas">inst_rom.coe</font>**  
    ```
    memory_initialization_radix=16;
    memory_initialization_vector=
    08000005
    00000000
    00000001
    00000001
    00000006
    20080006
    8c090010
    8c100008
    8c11000c
    02309020
    ac110008
    ac12000c
    11090001
    0800000c
    08000005;
    ```  
- **仿真代码 <font face="consolas">CPU_Mem_tb.v</font>**  
    ```verilog {.line-numbers}
    module CPU_Mem_tb#(parameter DIGIT = 32, ADDRWIDTH = 16, DEBUGSIZE = 8) ();

        wire clock;
        reg reset;
        reg run; 
        wire MemWrite;
        reg  [DEBUGSIZE - 1 : 0] ProbeAddress;
        wire [ADDRWIDTH - 1 : 0] MemAddress;
        wire     [DIGIT - 1 : 0] MemData;
        wire     [DIGIT - 1 : 0] RegData;
        wire 	 [DIGIT - 1 : 0] ProbePC;
        wire     [DIGIT - 1 : 0] ProbeRegData;
        wire     [DIGIT - 1 : 0] ProbeMemData;
        
        GenerateClock CLK (clock);
        MulticycleCPU CPU (clock, reset, run, MemData, ProbeAddress, MemWrite, MemAddress, RegData, ProbePC, ProbeRegData);
        Memory        MEM (MemAddress[DEBUGSIZE + 1 : 2], RegData, ProbeAddress, clock, MemWrite, MemData, ProbeMemData);

        initial
        begin
            reset = 1;
            run = 1;
            ProbeAddress = 'b00000000; 
            #20;
            reset = 0;
            ProbeAddress = 'b00000011;
        end

    endmodule
    ```
    ```verilog {.line-numbers}
    module GenerateClock(output reg Clk);
        parameter tON = 10,tOFF = 10;
        
        initial
        begin
                Clk = 0;
                forever
                begin
                    #tOFF Clk = 1;
                    #tON Clk = 0;
                end
        end
    endmodule
    ```
- **仿真截图**  
    ![多周期CPU仿真截图zoom fit](https://github.com/lyc0930/COD/blob/master/Fibonacci_VGA/Fibonacci_simulation_0.png?raw=true)  
    ![多周期CPU仿真分段1](https://github.com/lyc0930/COD/blob/master/Fibonacci_VGA/Fibonacci_simulation_1.png?raw=true)  
    ![多周期CPU仿真分段2](https://github.com/lyc0930/COD/blob/master/Fibonacci_VGA/Fibonacci_simulation_2.png?raw=true)  
    ![多周期CPU仿真分段3](https://github.com/lyc0930/COD/blob/master/Fibonacci_VGA/Fibonacci_simulation_3.png?raw=true)  
    ![多周期CPU仿真分段4](https://github.com/lyc0930/COD/blob/master/Fibonacci_VGA/Fibonacci_simulation_4.png?raw=true)  
    ![多周期CPU仿真分段5](https://github.com/lyc0930/COD/blob/master/Fibonacci_VGA/Fibonacci_simulation_5.png?raw=true)  
    **仿真截图说明：**  
    >&emsp;&emsp;&emsp;&emsp;以周期为20ns的时钟信号进行时长3000ns的仿真：通过设置`ProbeAddress`的值为`'b00000011`以观察在不同指令执行后3号存储器中的值，以确认斐波那契数列是否正确算出  
</br>
### 2. VGA显示信号模块   
- **程序代码**  
    1. **<font face="consolas">VGADisplayUnit.v</font>**  
        ```verilog {.line-numbers}
        module VGADisplayUnit(RGB, CLK100MHZ, reset, X, Y, VGA_R, VGA_G, VGA_B, VGA_HS, VGA_VS);
            input [11 : 0] RGB;
            input CLK100MHZ, reset;
            output [7 : 0] X, Y;
            output [3 : 0] VGA_R, VGA_G, VGA_B;
            output VGA_HS, VGA_VS;
            
            wire CLK50MHZ;
            wire [9 : 0] Point_X, Point_Y;
            wire DisplayEnable;

            //---------VGA signal------------
            //800x600@72Hz
            parameter H_PERIOD = 1040, 
                        HSPW = 120, 
                        HBP = 64, 
                        H_Length = 800, 
                        HFP = 56; 
            parameter V_PERIOD = 666, 
                        VSPW = 6, 
                        VBP = 23, 
                        V_Length = 600, 
                        VFP = 37;
                        
            Clocking_Wizard_1 CLK100MHZ_to_CLK50MHZ (CLK50MHZ, CLK100MHZ);
            Counter H_COUNT (CLK50MHZ, 0, H_PERIOD, Point_X);
            Counter V_COUNT (~(Point_X[9]), 0, V_PERIOD, Point_Y);

            // SPW|BP|Length|FP
            assign VGA_HS = ~(Point_X < HSPW);
            assign VGA_VS = ~(Point_Y < VSPW);
            assign DisplayEnable = 	   (Point_Y >= (VSPW + VBP)) 
                                    && (Point_Y < (V_PERIOD - VFP)) 
                                    && (Point_X >= (HSPW + HBP)) 
                                    && (Point_X < (H_PERIOD - HFP));
            assign VGA_R = DisplayEnable ? RGB[11 : 8] : 0;
            assign VGA_G = DisplayEnable ? RGB[ 7 : 4] : 0;
            assign VGA_B = DisplayEnable ? RGB[ 3 : 0] : 0;
            //-------------------------------
            assign X = Point_X - (HSPW + HBP);
            assign Y = Point_Y - (VSPW + VBP);

        endmodule
        ```
    2. **<font face="concolas">Counter.v</font>**  
        ```verilog {.line-numbers}
        module Counter(
            input clock,             
            input reset,             
            input [15:0] Range,     
            output reg [15:0] Counter 
        );

            always@(posedge clock or posedge reset) 
            begin
                if (reset) 
                    Counter <= 0;
                else 
                    if(Counter == Range - 1) 
                        Counter <= 0;
                    else 
                        Counter <= Counter + 1;
            end

        endmodule
        ```
- **下载照片**  
    >&emsp;&emsp;&emsp;&emsp;由于个人完成实验检查时的疏忽以及缺少外设、开发板上交归还以及实验室开放时间有限等原因，此次实验未能完成下载效果的拍照  
</br> 
## 实验总结
<p>&emsp;&emsp;本次实验作为本学期组成原理附属实验课程的最后一次实验，通过例化前次实验完成的多周期CPU、编写汇编代码并翻译为机器码、连接外设，实现了一个综合性较高的实验工程，计算斐波那契数列并显示在VGA显示器上，虽然功能仍相对简单，但是编写汇编代码以及连接CPU、存储器、外设的实验过程极为有效地帮助理解了计算机组成原理的课程内容，使得对于计算机的功能部件组成与功能实现有了更为具象的认识，也纠正了很多在理论课程学习过程中出现的误解。</p>  
<p>&emsp;&emsp;经过又一学期在Vivado环境下Verilog硬件语言的编写，在实验过程中学习了很多相关的语法知识与开发技巧，锻炼了编码与调试的耐心与细致，培养了更为优雅的可拓展性高、可读性好、模块化程度深的编程风格，对于硬件开发有了进一步的理解，为今后课程的学习留下了基础与经验。</p>  

## 附
&emsp;&emsp;本报告中出现的所有设计与测试源代码文件以及相关截图与照片可见  
&emsp;&emsp;[GitHub@lyc0930](https://github.com/lyc0930/COD)