# <center>实验报告</center>
### <center>实验五	多周期MIPS-CPU</center>
##### <p align="right">罗晏宸</br>PB17000297</br>2019.5.9</p>
***
## 实验目的  
1. **多周期CPU的实现**  
    &emsp;&emsp;通过例化此前实现的ALU、寄存器堆等模块，并编写控制单元、程序计数器与CPU顶层模块，完成一个能执行MIPS指令集一个子集中全部指令的CPU多周期实现，指令如下：  
    - `add`, `sub`, `and`, `or`, `xor`, `nor`, `slt`  
    - `addi`, `andi`, `ori`, `xori`, `slti`  
    - `lw`, `sw`  
    - `beq`, `bne`, `j`  
2. **设计并实现调试CPU与显示单元————Debug and Display Unit**  
    &emsp;&emsp;DDU在下载测试时，用于控制CPU运行方式（连续执行或单次执行一个时钟周期）和显示运行结果   
3. **通过调试CPU理解指令执行的原理与数据通路**  
    &emsp;&emsp;利用例化IP核实现存储器，利用DDU调试设计完成的多周期CPU，观察寄存器与存储器中各地址下数据的变化以确定指令执行的结果  
***
## 实验内容  
### 1. 多周期CPU  
- **程序代码**  
    1. **<font face="consolas">MultipleCPU.v</font>**
        ```verilog {.line-numbers}
        module MulticycleCPU #(parameter DIGIT = 32, FIELDWIDTH = 5, ADDRWIDTH = 16, DEBUGSIZE = 8)
        (CLK, reset, run, MemData, ProbeAddress, MemWrite, MemAddress, RegReadData_1_RegOut, ProbePC, ProbeRegData);
            input CLK;
            input reset;
            input run;
            input      [DIGIT - 1 : 0] MemData;
            input  [DEBUGSIZE - 1 : 0] ProbeAddress;
            
            output MemWrite;
            output [ADDRWIDTH - 1 : 0] MemAddress;
            output     [DIGIT - 1 : 0] RegReadData_1_RegOut;
            output     [DIGIT - 1 : 0] ProbePC;
            output     [DIGIT - 1 : 0] ProbeRegData;
                
            // Control signal
            wire         PCWriteCondition_0;
            wire         PCWriteCondition_1;
            wire         PCWrite;
            wire         IorD;
            wire         MemtoReg;
            wire         IRWrite;
            wire [1 : 0] PCSource;
            wire [2 : 0] ALUOp;
            wire         ALUSrcA;
            wire [1 : 0] ALUSrcB;
            wire         RegWrite;
            wire         RegDst;
            wire [3 : 0] ALUControlSignal;
            
            // Wires
            wire      [DIGIT - 1 : 0] PCOut; 
            wire      [DIGIT - 1 : 0] Instruction;
            wire      [DIGIT - 1 : 0] MemData_RegOut;
            wire [FIELDWIDTH - 1 : 0] RegWriteAddress;
            wire      [DIGIT - 1 : 0] RegWriteData;
            wire      [DIGIT - 1 : 0] RegReadData_0, RegReadData_1;
            wire      [DIGIT - 1 : 0] RegReadData_0_RegOut;
            wire      [DIGIT - 1 : 0] ALUSource_A;
            wire      [DIGIT - 1 : 0] ALUSource_B;
            wire      [DIGIT - 1 : 0] Instruction_Extended;
            wire      [DIGIT - 1 : 0] ALUResult;
            wire              [3 : 0] ALUFlags;
            wire      [DIGIT - 1 : 0] ALUOut;
            wire      [DIGIT - 1 : 0] NextPC;
            
            // Decode
            wire              [5 : 0] op;
            wire [FIELDWIDTH - 1 : 0] rs, rt, rd, shamt;
            wire              [5 : 0] funct;
            
            assign {op, rs, rt, rd, shamt, funct} = Instruction; // R-type
            
            // Debug
            wire clock;
            
            assign ProbePC = PCOut;
            assign clock = run & CLK;
            
            // Connection
            ControlUnit 		             CU                       (clock, reset, op, PCWriteCondition_0, PCWriteCondition_1, PCWrite, IorD, MemWrite, MemtoReg, IRWrite, PCSource, ALUOp, ALUSrcA, ALUSrcB, RegWrite, RegDst);
            ProgramCounter                   PC                       (clock, reset, NextPC, ((ALUFlags[0] & PCWriteCondition_0) | (~ALUFlags[0] & PCWriteCondition_1) | PCWrite), PCOut);
            Multiplexer #(2, DIGIT)          MUX_MemAddress           (PCOut, ALUOut, , , IorD, MemAddress);
            InstructionRegister  			 IR                       (clock, IRWrite, MemData, Instruction);
            Register                         MDR                      (clock, MemData, MemData_RegOut);
            Multiplexer #(2, FIELDWIDTH)     MUX_RegisterWriteAddress (rt, rd, , , RegDst, RegWriteAddress);
            Multiplexer #(2, DIGIT)          MUX_RegisterWriteData    (ALUOut, MemData_RegOut, , , MemtoReg, RegWriteData);
            Registers   #(FIELDWIDTH, DIGIT) DR                       (clock, reset, rs, rt, ProbeAddress, RegWriteAddress, RegWriteData, RegWrite, RegReadData_0, RegReadData_1, ProbeRegData);
            SignExtend			             EX                       (Instruction[15 : 0], Instruction_Extended);
            Register                         A                        (clock, RegReadData_0, RegReadData_0_RegOut);
            Register                         B                        (clock, RegReadData_1, RegReadData_1_RegOut);
            Multiplexer #(2, DIGIT)          MUX_ALUSourceA           (PCOut, RegReadData_0_RegOut, , , ALUSrcA, ALUSource_A);
            Multiplexer #(4, DIGIT)          MUX_ALUSourceB           (RegReadData_1_RegOut, 'd4, Instruction_Extended, (Instruction_Extended << 2), ALUSrcB, ALUSource_B);
            ALUControl		                 ALUCTRL                  (funct, ALUOp, ALUControlSignal);
            ALU	                             ALU                      (ALUControlSignal, ALUSource_A, ALUSource_B, ALUResult, ALUFlags);
            Register                         ALUOUT                   (clock, ALUResult, ALUOut);
            Multiplexer #(3, DIGIT)          MUX_NextPC               (ALUResult, ALUOut, {PCOut[31 : 28], Instruction[25 : 0], 2'b00}, , PCSource, NextPC);

        endmodule
        ```
    2. **<font face="consolas">MUX.v</font>**
        ```verilog {.line-numbers}
        module Multiplexer #(parameter N = 2, DATASIZE = 32)(in_0, in_1, in_2, in_3, s, out);
            input      [DATASIZE - 1 : 0] in_0, in_1, in_2, in_3;
            input                 [1 : 0] s;
            
            output reg [DATASIZE - 1 : 0] out;

            initial
            begin
                out = 'b0;
            end
            
            always @(*)
            begin
                if (s >= N)
                    out = 'b0;
                else
                    case (s)
                        2'b00: out = in_0;
                        2'b01: out = in_1; 
                        2'b10: out = in_2; 
                        2'b11: out = in_3; 
                        2'bx0: out = in_0; 
                        2'bx1: out = in_1;
                        2'bz0: out = in_0; 
                        2'bz1: out = in_1;
                        default: 
                            out = 'b1111; 
                    endcase
                end

        endmodule
        ```
    3. **<font face="consolas">ControlUnit.v</font>**
        ```verilog {.line-numbers}
        module ControlUnit(clock, reset, op, PCWriteCondition_0, PCWriteCondition_1, PCWrite, IorD, MemWrite, 
        MemtoReg, IRWrite, PCSource, ALUOp, ALUSrcA, ALUSrcB, RegWrite, RegDst, CurrentState, NextState);
            input clock;
            input reset;
            input      [5 : 0] op;

            output reg PCWriteCondition_0;
            output reg PCWriteCondition_1;
            output reg PCWrite;
            output reg IorD;
        //	output reg MemRead;
            output reg MemWrite;
            output reg MemtoReg;
            output reg IRWrite;
            output reg [1 : 0] PCSource;
            output reg [2 : 0] ALUOp;
            output reg ALUSrcA;
            output reg [1 : 0] ALUSrcB;
            output reg RegWrite;
            output reg RegDst;
            
            // State
            output reg [16 : 0] CurrentState, NextState;
            parameter Idle                 = 17'b0,
                    InstructionFetch     = 1 <<  0,
                    InstructionDecode    = 1 <<  1,
                    MemoryAddressCompute = 1 <<  2,
                    MemoryAccess_LW      = 1 <<  3,
                    MemoryReadComplete   = 1 <<  4,
                    MemoryAccess_SW      = 1 <<  5,
                    RTypeExecution       = 1 <<  6,
                    RTypeComplete        = 1 <<  7,
                    ADDIExecution        = 1 <<  8,
                    ANDIExecution        = 1 <<  9,
                    ORIExecution         = 1 << 10,
                    XORIExecution        = 1 << 11,
                    SLTIExecution        = 1 << 12,
                    ITypeComplete        = 1 << 13,
                    BEQComplete          = 1 << 14,
                    BNEComplete          = 1 << 15,
                    JumpComplete         = 1 << 16;
            
            initial
            begin
                CurrentState       = Idle;
                PCWriteCondition_0 = 0;
                PCWriteCondition_1 = 0;
                PCWrite 	       = 0;
                IorD 		       = 0;
                MemWrite 	       = 0;
                MemtoReg 	       = 0;
                IRWrite 	       = 0;
                PCSource 	       = 2'b00;
                ALUOp 		       = 3'b000;
                ALUSrcA 	       = 0;
                ALUSrcB 	       = 2'b00;
                RegWrite 	       = 0;
                RegDst 		       = 0;
            end
            
            always @(posedge clock or posedge reset)
            begin
                if (reset)
                    CurrentState <= Idle;
                else
                    CurrentState <= NextState;
            end
            
            always @(*)
            begin
                case (CurrentState)
                
                    Idle:
                    begin
                        NextState = InstructionFetch;
                    end
                
                    InstructionFetch: 
                    begin
                        NextState = InstructionDecode;
                    end
                    
                    InstructionDecode: 
                    begin				
                        case (op)
                            6'b100011: // LW
                                NextState = MemoryAddressCompute;
                            6'b101011: // SW
                                NextState = MemoryAddressCompute;
                            6'b000000: // R-type
                                NextState = RTypeExecution;
                            6'b001000: // ADDI
                                NextState = ADDIExecution; 
                            6'b001100: // ANDI 
                                NextState = ANDIExecution;
                            6'b001101: //  ORI  
                                NextState = ORIExecution;
                            6'b001110: // XORI 
                                NextState = XORIExecution;
                            6'b001010: // SLTI 
                                NextState = SLTIExecution;
                            6'b000100: // BEQ
                                NextState = BEQComplete;
                            6'b000101: // BNE
                                NextState = BNEComplete;
                            6'b000010: // J
                                NextState = JumpComplete;
                            default : 
                                NextState = InstructionFetch;
                        endcase
                    end
                    
                    MemoryAddressCompute: 
                    begin				
                        case (op)
                            6'b100011: // LW
                                NextState = MemoryAccess_LW;
                            6'b101011: // SW
                                NextState = MemoryAccess_SW;
                            default : 
                                NextState = InstructionFetch;
                        endcase
                    end
                    
                    MemoryAccess_LW: 
                    begin
                        NextState = MemoryReadComplete;
                    end
                    
                    MemoryReadComplete: 
                    begin
                        NextState = InstructionFetch;
                    end
                    
                    MemoryAccess_SW: 
                    begin
                        NextState = InstructionFetch;
                    end
                        
                    RTypeExecution: 
                    begin
                        NextState = RTypeComplete;
                    end
                    
                    RTypeComplete: 
                    begin
                        NextState = InstructionFetch;
                    end
                    
                    ADDIExecution: 
                    begin
                        NextState = ITypeComplete;
                    end
                    
                    ANDIExecution: 
                    begin
                        NextState = ITypeComplete;
                    end
                    
                    ORIExecution: 
                    begin
                        NextState = ITypeComplete;
                    end
                    
                    XORIExecution: 
                    begin
                        NextState = ITypeComplete;
                    end
                    
                    SLTIExecution: 
                    begin
                        NextState = ITypeComplete;
                    end
                    
                    ITypeComplete: 
                    begin
                        NextState = InstructionFetch;
                    end
                    
                    BEQComplete: 
                    begin
                        NextState = InstructionFetch;
                    end
                    
                    BNEComplete: 
                    begin
                        NextState = InstructionFetch;
                    end
                    
                    JumpComplete: 
                    begin
                        NextState = InstructionFetch;
                    end
                    
                    default :
                        NextState = InstructionFetch;
                endcase 
            end
            
            always @(posedge clock or posedge reset)
            begin
                if (reset)
                begin
                    PCWriteCondition_0 <= 0;
                    PCWriteCondition_1 <= 0;
                    PCWrite 	       <= 0;
                    IorD 		       <= 0;
                    MemWrite 	       <= 0;
                    MemtoReg 	       <= 0;
                    IRWrite 	       <= 0;
                    PCSource 	       <= 2'b00;
                    ALUOp 		       <= 3'b000;
                    ALUSrcA 	       <= 0;
                    ALUSrcB 	       <= 2'b00;
                    RegWrite 	       <= 0;
                    RegDst 		       <= 0;
                end
                else
                begin
                    case (NextState)
                        Idle:
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        InstructionFetch: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                                PCWrite 	       <= 1;
                                IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                                IRWrite 	       <= 1;
                                PCSource           <= 2'b00;
                                ALUOp 		       <= 3'b000;
                                ALUSrcA 	       <= 0;
                                ALUSrcB 	       <= 2'b01;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        InstructionDecode: 
                        begin				
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp 		       <= 3'b000;
                                ALUSrcA 	       <= 0;
                                ALUSrcB 	       <= 2'b11;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        MemoryAddressCompute: 
                        begin				
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp 		       <= 3'b000;
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b10;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        MemoryAccess_LW: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                                IorD               <= 1;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        MemoryReadComplete: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                                MemtoReg 	       <= 1;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                                RegWrite 	       <= 1;
                                RegDst 		       <= 0;
                        end
                        
                        MemoryAccess_SW: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                                IorD 		       <= 1;
                                MemWrite 	       <= 1;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                            
                        RTypeExecution: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp 		       <= 3'b010;
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        RTypeComplete: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                                MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                                RegWrite 	       <= 1;
                                RegDst 		       <= 1;
                        end
                        
                        ADDIExecution: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp              <= 3'b011; 
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b10;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        ANDIExecution: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp              <= 3'b100; 
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b10;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        ORIExecution: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp              <= 3'b101; 
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b10;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        XORIExecution: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp              <= 3'b110; 
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b10;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        SLTIExecution: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                                ALUOp              <= 3'b111; 
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b10;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        ITypeComplete: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                                MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                                RegWrite 	       <= 1;
                                RegDst 		       <= 0;
                        end
                        
                        BEQComplete: 
                        begin
                                PCWriteCondition_0 <= 1;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                                PCSource 	       <= 2'b01;
                                ALUOp 		       <= 3'b001;
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        BNEComplete: 
                        begin
                            PCWriteCondition_0 <= 0;
                                PCWriteCondition_1 <= 1;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                                PCSource 	       <= 2'b01;
                                ALUOp 		       <= 3'b001;
                                ALUSrcA 	       <= 1;
                                ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        JumpComplete: 
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                                PCWrite 	       <= 1;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                                PCSource 	       <= 2'b10;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                        
                        default :
                        begin
                            PCWriteCondition_0 <= 0;
                            PCWriteCondition_1 <= 0;
                            PCWrite 	       <= 0;
                            IorD 		       <= 0;
                            MemWrite 	       <= 0;
                            MemtoReg 	       <= 0;
                            IRWrite 	       <= 0;
                            PCSource 	       <= 2'b00;
                            ALUOp 		       <= 3'b000;
                            ALUSrcA 	       <= 0;
                            ALUSrcB 	       <= 2'b00;
                            RegWrite 	       <= 0;
                            RegDst 		       <= 0;
                        end
                    endcase 
                end 
            end
            
        endmodule
        ```
    4. **<font face="consolas">ProgramCounter.v</font>**
        ```verilog {.line-numbers}
        module ProgramCounter #(parameter DIGIT = 32)(clock, reset, NextPC, PCWrite, IAddress);
            input clock;
            input reset;
            input      [DIGIT - 1 : 0] NextPC;
            input PCWrite;
            
            output reg [DIGIT - 1 : 0] IAddress;

            initial 
            begin
                IAddress = 'b0;
            end
            
            always @(posedge clock or posedge reset)
            begin 
                if(reset) 
                    IAddress <= 'b0;
                else 
                begin
                    if (PCWrite) 
                        IAddress <= NextPC;
                    else 
                        IAddress <= IAddress;
                end
            end

        endmodule
        ```
    5. **<font face="consolas">InstructionRegister.v</font>**
        ```verilog {.line-numbers}
        module InstructionRegister #(parameter DIGIT = 32)
        (clock, IRWrite, MemData, Instruction);
            input clock; 
            input IRWrite; 
            input      [DIGIT - 1 : 0] MemData; 
            
            output reg [DIGIT - 1 : 0] Instruction;
            
            reg [31:0] Register;
            
            initial 
            begin
                Register    = 'b0;
                Instruction = 'b0;
            end
            
            always @(negedge clock) 
            begin
                if (IRWrite)
                    Register <= MemData;
                else
                    Register <= Register;
            end
            
            always @(posedge clock) 
            begin
                Instruction <= Register;
            end
            
        endmodule
        ```
    6. **<font face="consolas">Register.v</font>**
        ```verilog {.line-numbers}
        module Register #(parameter DIGIT = 32)(clock, In, Out);
            input clock;
            input      [31:0] In;
            
            output reg [31:0] Out;
            
            reg [31:0] Register;

            initial 
            begin
                Out      = 'b0;
                Register = 'b0;
            end
            
            always@(negedge clock) 
            begin
                Register <= In;
            end
            
            always@(posedge clock) 
            begin
                Out <= Register;
            end 
        
        endmodule
        ```
    7. **<font face="consolas">Registers.v</font>**
        ```verilog {.line-numbers}
        module Registers #(parameter REGSIZE = 5, DIGIT = 32)
        (clock, reset, Read_Address_0, Read_Address_1, Read_Address_2, Write_Address, Write_Data, 
        Write_Enable, Read_Data_0, Read_Data_1, Read_Data_2);
            input clock, reset;
            input Write_Enable;
            input  [REGSIZE - 1 : 0] Read_Address_0, Read_Address_1, Read_Address_2;
            input  [REGSIZE - 1 : 0] Write_Address;
            input    [DIGIT - 1 : 0] Write_Data;
            
            output   [DIGIT - 1 : 0] Read_Data_0, Read_Data_1, Read_Data_2;
            
            reg [DIGIT - 1 : 0] Register [1 : (1 << REGSIZE) - 1];
            integer i;
            
            assign Read_Data_0 = (Read_Address_0 == 0) ? 'b0 : Register[Read_Address_0];
            assign Read_Data_1 = (Read_Address_1 == 0) ? 'b0 : Register[Read_Address_1];
            assign Read_Data_2 = (Read_Address_2 == 0) ? 'b0 : Register[Read_Address_2];
            
            initial
            begin
                for (i = 1; i < DIGIT; i = i + 1)
                    Register[i] = 'b0;
            end
            
            always  @(posedge clock or posedge reset)
            begin
                if (reset)
                begin
                    for (i = 1; i < DIGIT; i = i + 1)
                        Register[i] <= 0;
                end
                else
                begin
                    if ((Write_Address != 0) && Write_Enable)
                        Register[Write_Address] <= Write_Data;
                end
            end

        endmodule
        ```
    8. **<font face="consolas">ALU.v</font>**
        ```verilog {.line-numbers}
        module ALU #(parameter  DIGIT = 32, CTRLSIZE = 4, FLAGSIZE = 4)(Control, A, B, Out, Flags);
            input  wire [CTRLSIZE - 1 : 0] Control;
            input  wire    [DIGIT - 1 : 0] A;
            input  wire    [DIGIT - 1 : 0] B;
            
            output  reg    [DIGIT - 1 : 0] Out;
            output wire [FLAGSIZE - 1 : 0] Flags;

            wire Carry_Borrow, Negative, Overflow, Zero;
            wire Carry, Borrow;
            wire [DIGIT - 1 : 0] add_sum, minus_sum;

            always @(*)
            begin
                case (Control)
                    4'b0000: Out = A + B;
                    4'b0001: Out = A + (~B + 'b1);//(F == 1) ? (('b1 << 6) - minus_sum) : minus_sum;
                    4'b1000: Out = A & B;
                    4'b1001: Out = A | B;
                    4'b1010: Out = ~A;
                    4'b1011: Out = ~(A | B);
                    4'b1100: Out = A ^ B;
                    4'b1101: Out = (A < B) ? 'b1 : 'b0;
                    default: 
                        Out = 'b0;
                endcase 
            end

            assign Flags               = {Carry_Borrow, Negative, Overflow, Zero};
            assign Carry_Borrow        = ~Control[CTRLSIZE - 1] && ((Control[0] == 0) ? Carry : Borrow);
            assign {Carry, add_sum}    = A + B;
            assign {Borrow, minus_sum} = A - B;	
            assign Negative            = ~Control[CTRLSIZE - 1] && (Overflow ^ Out[DIGIT - 1]);
            assign Overflow            = ~Control[CTRLSIZE - 1] && ((Control[0] ^~ (A[DIGIT - 1] ^ B[DIGIT - 1])) && (A[DIGIT - 1] ^ Out[DIGIT - 1]));
            assign Zero                = (Out == 'b0);

        endmodule
        ```
    9. **<font face="consolas">ALUControl.v</font>**
        ```verilog {.line-numbers}
        module ALUControl #(parameter CTRLSIZE = 4)(funct, Operation, ControlSignal);
            input                 [5 : 0] funct;
            input                 [2 : 0] Operation;
            
            output reg [CTRLSIZE - 1 : 0] ControlSignal;
            
            initial
            begin
                ControlSignal = 4'b0000;
            end
            
            always @(*)
            begin
                case (Operation)
                    3'b000: ControlSignal = 4'b0000; // LW SW --> ADD
                    3'b001: ControlSignal = 4'b0001; // BEQ --> SUB
                    3'b010: 
                        case (funct)
                            6'b100000: ControlSignal = 4'b0000; // ADD
                            6'b100010: ControlSignal = 4'b0001; // SUB
                            6'b100100: ControlSignal = 4'b1000; // AND
                            6'b100101: ControlSignal = 4'b1001; //  OR
                            6'b100110: ControlSignal = 4'b1100; // XOR
                            6'b100111: ControlSignal = 4'b1011; // NOR
                            6'b101010: ControlSignal = 4'b1101; // SLT
                            default:
                                ControlSignal = 4'b0000;
                        endcase
                    3'b011: ControlSignal = 4'b0000; // ADDI 001000
                    3'b100: ControlSignal = 4'b1000; // ANDI 001100
                    3'b101: ControlSignal = 4'b1001; //  ORI 001101
                    3'b110: ControlSignal = 4'b1100; // XORI 001110
                    3'b111: ControlSignal = 4'b1101; // SLTI 001010
                    default:
                        ControlSignal = 4'b0000;
                endcase 
            end
        
        endmodule
        ```
    10. **<font face="consolas">SignExtend.v</font>**
        ```verilog {.line-numbers}
        module SignExtend #(parameter DIGIT = 16)(In, Out);
            input      [DIGIT - 1 : 0] In;
            
            output [2 * DIGIT - 1 : 0] Out;
            
            assign Out[    DIGIT - 1 : 0    ] = In;
            assign Out[2 * DIGIT - 1 : DIGIT] = In[DIGIT - 1] ? {DIGIT{1'b1}} : {DIGIT{1'b0}};

        endmodule
        ```
- **原理逻辑电路图**  
    ![多周期CPU状态图](https://github.com/lyc0930/COD/blob/master/MulticycleCPU/%E7%8A%B6%E6%80%81%E5%9B%BE.png?raw=true)  
    ![多周期CPU原理](https://github.com/lyc0930/COD/blob/master/MulticycleCPU/CPU_RTL.png?raw=true)  
    **逻辑设计说明：**  
    >&emsp;&emsp;&emsp;&emsp;多周期CPU模块`MultipleCPU`通过组合连接各功能单元与多选器`Multiplexer`、寄存器`Register`等，在嵌有状态机的控制单元`ControlUnit`输出的各个控制信号下完成各指令的多周期实现  
    >&emsp;&emsp;&emsp;&emsp;如依据本次实验中所实现的指令子集重绘的状态图所示，共有18个不同的状态，不同颜色对不同类型指令执行的状态转移做了区分，并以背景中的三个同心圆显示各指令类型需要的时间周期数————3～5不等。  
- **仿真代码 <font face="consolas">CPU_Mem_tb.v</font>**
    ```verilog {.line-numbers}
    module CPU_Mem_tb#(parameter DIGIT = 32, ADDRWIDTH = 16, DEBUGSIZE = 8) ();
        wire clock;
        reg reset;
        reg run; 
        wire MemWrite;
        reg  [DEBUGSIZE - 1 : 0] ProbeAddress;
        wire [ADDRWIDTH - 1 : 0] MemAddress;
        wire     [DIGIT - 1 : 0] MemData;
        wire     [DIGIT - 1 : 0] RegData;
        wire 	 [DIGIT - 1 : 0] ProbePC;
        wire     [DIGIT - 1 : 0] ProbeRegData;
        wire     [DIGIT - 1 : 0] ProbeMemData;
        
        GenerateClock CLK (clock);
        MulticycleCPU CPU (clock, reset, run, MemData, ProbeAddress, MemWrite, MemAddress, RegData, ProbePC, ProbeRegData);
        Memory        MEM (MemAddress[DEBUGSIZE + 1 : 2], RegData, ProbeAddress, clock, MemWrite, MemData, ProbeMemData);

        initial
        begin
            reset = 1;
            run = 1;
            ProbeAddress = 'b00000000; 
            #20;
            reset = 0;
            ProbeAddress = 'b00000000;  #80; //    j    _start
            ProbeAddress = 'b00001000;  #80; // t0 addi $t0,$0,3
            ProbeAddress = 'b00001001;  #80; // t1 addi $t1,$0,5
            ProbeAddress = 'b00001010;  #80; // t2 addi $t2,$0,1
            ProbeAddress = 'b00010000; #100; // s0 add  $s0,$t1,$t0
            ProbeAddress = 'b00010001; #120; // s1 lw   $s1,12($0)
            ProbeAddress = 'b00010000;  #80; // s0 bne  $s1,$s0,_fail
            ProbeAddress = 'b00010000; #100; // s0 and  $s0,$t1,$t0
            ProbeAddress = 'b00010001; #120; // s1 lw   $s1,16($0)
            ProbeAddress = 'b00010000;  #80; // s0 bne  $s1,$s0,_fail
            ProbeAddress = 'b00010000; #100; // s0 xor  $s0,$t1,$t0
            ProbeAddress = 'b00010001; #120; // s1 lw   $s1,20($0)
            ProbeAddress = 'b00010000;  #80; // s0 bne  $s1,$s0,_fail
            ProbeAddress = 'b00010000; #100; // s0 nor  $s0,$t1,$t0
            ProbeAddress = 'b00010001; #120; // s1 lw   $s1,24($0)
            ProbeAddress = 'b00010000;  #80; // s0 bne  $s1,$s0,_fail
            ProbeAddress = 'b00010000; #100; // s0 slt  $s0,$t0,$t1
            ProbeAddress = 'b00010001; #120; // s1 lw   $s1,28($0)
            ProbeAddress = 'b00010000;  #80; // s0 bne  $s1,$s0,_fail
            ProbeAddress = 'b00010000; #100; // s0 andi $s0,$t0,7
            ProbeAddress = 'b00010001; #120; // s1 lw   $s1,32($0)
            ProbeAddress = 'b00010000;  #80; // s0 bne  $s1,$s0,_fail
            ProbeAddress = 'b00010000; #100; // s0 ori  $s0,$t1,4
            ProbeAddress = 'b00010001; #120; // s1 lw   $s1,36($0)
            ProbeAddress = 'b00010000;  #80; // s0 bne  $s1,$s0,_fail
            ProbeAddress = 'b00001010; #100; // $10sw   $t1,40($0)
            ProbeAddress = 'b00010001; #120; // s1 lw   $s1,40($0)
            ProbeAddress = 'b00001010;  #80; // s0 beq  $t1,$s1,_sucess
            ProbeAddress = 'b00000010; #100; // $2 sw   $t2,8($0)

        end
    endmodule
    ```
    ```verilog {.line-numbers}
    module GenerateClock(output reg Clk);
        parameter tON = 10,tOFF = 10;
        
        initial
        begin
                Clk = 0;
                forever
                begin
                    #tOFF Clk = 1;
                    #tON Clk = 0;
                end
        end
    endmodule
    ```
- **仿真截图**  
    ![多周期CPU仿真截图zoom fit](https://github.com/lyc0930/COD/blob/master/MulticycleCPU/simulation_fit.png?raw=true)  
    ![多周期CPU仿真分段1](https://github.com/lyc0930/COD/blob/master/MulticycleCPU/simulation_1.png?raw=true)  
    ![多周期CPU仿真分段2](https://github.com/lyc0930/COD/blob/master/MulticycleCPU/simulation_2.png?raw=true)  
    ![多周期CPU仿真分段3](https://github.com/lyc0930/COD/blob/master/MulticycleCPU/simulation_3.png?raw=true)  
    ![多周期CPU仿真分段4](https://github.com/lyc0930/COD/blob/master/MulticycleCPU/simulation_4.png?raw=true)  
    **仿真截图说明：**  
    >&emsp;&emsp;&emsp;&emsp;以周期为20ns的时钟信号进行时长3000ns的仿真：通过反复设置`ProbeAddress`的值为`'b00001000`、`'b00001001`、`'b00001010`、`'b00010000`、`'b00010001`以分别观察在不同指令执行后寄存器`t0`、`t1`、`t2`、`s0`、`s1`中的值；最终设置`ProbeAddress`的值为`'b00000010`，观察2号存储器中的值是否为`1`以确认最后一条测试指令是否已正确执行  
</br>
### 2. 调试与显示模块DDU  
- **程序代码**  
    1. **<font face="concolas">DebugandDisplayUnit.v</font>**  
        ```verilog {.line-numbers}
        module DebugandDisplayUnit #(DIGIT = 32, DEBUGSIZE = 8)(CLK100MHZ, reset, continue, step, probe, inc, dec, ProbePC, ProbeMemData, ProbeRegData, run, clock, ProbeAddress, DisplayPC, AN, seg);
            input CLK100MHZ, reset;
            input continue, step, probe, inc, dec;
            input  [DEBUGSIZE - 1 : 0] ProbePC; 
            input      [DIGIT - 1 : 0] ProbeMemData, ProbeRegData;
            
            output run;
            output clock;
            output [DEBUGSIZE - 1 : 0] ProbeAddress;
            output [DEBUGSIZE - 1 : 0] DisplayPC; 
            output             [7 : 0] AN;
            output             [6 : 0] seg;
            
            wire CLK5MHZ;
            wire singlePulse;

            wire inc_s, dec_s;
            reg [DEBUGSIZE - 1 : 0] increment;
            reg [DEBUGSIZE - 1 : 0] decrement;

            wire         [2 : 0] pulse;
            wire [DIGIT - 1 : 0] DisplayData;
            reg          [3 : 0] SegmentData;

            initial
            begin
                SegmentData  = 'b0;
                increment    = 'b0;
                decrement    = 'b0;
            end

            // Clock, running control
            ClockWizard        CLK100MHZ_to_5MHZ (CLK5MHZ, CLK100MHZ);
            FrequencyDivision  SecondPulse       (CLK5MHZ, 'b0, clock);
            SinglePulse        SingleSecondPulse (clock, reset, step, singlePulse);
            assign run = (continue ? 1 : singlePulse);
            
            // Address change
            Debounce           incStabilize      (CLK5MHZ, inc, inc_s);
            Debounce           decStabilize      (CLK5MHZ, dec, dec_s);
            assign ProbeAddress = increment + decrement;
            
            always @(posedge inc_s or posedge reset)
            begin
                if (reset)
                    increment <= 'b0;
                else
                begin
                    if (inc_s)
                        increment <= increment + 'b1;
                end
            end	
            
            always @(posedge dec_s or posedge reset)
            begin
                if (reset)
                    decrement <= 'b0;
                else
                begin
                    if (dec_s)
                        decrement <= decrement - 'b1;
                end
            end	
            
            // LED
            assign DisplayPC = ProbePC;
            
            // 7 Segment Display
            DisplayPulse       SegmentChoose     (CLK100MHZ, 'b0, pulse); 
            Hex7SegmentDisplay SegmentDisplay    (SegmentData, seg);

            assign DisplayData = (probe ? ProbeMemData : ProbeRegData);
            
            always @(*)
            begin
                case (pulse)
                    'd0: SegmentData <= DisplayData[ 3 :  0];
                    'd1: SegmentData <= DisplayData[ 7 :  4];
                    'd2: SegmentData <= DisplayData[11 :  8];
                    'd3: SegmentData <= DisplayData[15 : 12];
                    'd4: SegmentData <= DisplayData[19 : 16];
                    'd5: SegmentData <= DisplayData[23 : 20];
                    'd6: SegmentData <= DisplayData[27 : 24];
                    'd7: SegmentData <= DisplayData[31 : 28];
                endcase 
            end

            genvar i;
            generate
                for (i = 0; i < 8; i = i + 1) 
                begin: SegmentDisplaySignal
                    assign AN[i] = (pulse == i) ? 0 : 1;
                end
            endgenerate

        endmodule
        ```
    2. **<font face="concolas">FrequencyDivision.v</font>**  
        ```verilog {.line-numbers}
        module FrequencyDivision(input Origin_Clock, input reset, output pulse);
        reg [23:0] count;
            
            initial
            begin
                count = 'b0;
            end
            
            always @(posedge Origin_Clock or posedge reset)
            begin
                if (reset)
                    count <= 'd0;  		
                else 
                begin
                    if(count >= 'd4999999)
                        count <= 'd0;
                    else
                        count <= count + 'd1;
                end
            end
            
            assign	pulse =  (count == 'd2499999) ? 1'b1 : 1'b0;
            
        endmodule
        ```
    3. **<font face="concolas">SinglePulse.v</font>**  
        ```verilog {.line-numbers}
        module SinglePulse(clock, reset, signal, pulse);
            input  clock;
            input  reset; 
            input  signal; 
            output pulse; 

            reg delay_0;
            reg delay_1;
            
            initial
            begin
                delay_0 = 'b0;
                delay_1 = 'b0;
            end
            
            always @(negedge clock or posedge signal)
            begin
                if (signal)
                    delay_0 <= 1;
                else
                    delay_0 <= 0;
            end
            
            always @(posedge clock or posedge reset)
            begin
                if(reset)
                    delay_1 <= 'd0;
                else
                    delay_1 <= delay_0;
            end

            assign pulse = delay_0 & delay_1 & clock;

        endmodule
        ```
    4. **<font face="consolas">Debounce.v</font>**
        ```verilog {.line-numbers}
        module Debounce(
            input clock,
            input button,
            output reg button_s
            );
            
            reg [20 : 0] count;
            reg count_enable;
            
            parameter LIMIT = 100_000; // 5MHz --> 20ms
            
            always @(posedge clock)
            begin
                if (count == LIMIT - 1)
                    button_s <= button;
            end
            
            always @(posedge clock)
            begin
                if (count_enable)
                    count <= count + 'b1;
                else
                    count <= 'b0;
            end
            
            always @(posedge clock)
            begin
                if (~count_enable && (button != button_s))
                    count_enable <= 1;
                else
                    if (count == LIMIT - 1)
                        count_enable <= 0;
            end
            
        endmodule
        ```
    5. **<font face="concolas">DisplayPulse.v</font>**    
        ```verilog {.line-numbers}
        module DisplayPulse(input Origin_Clock, input reset, output [2 : 0] pulse);
            reg [17:0] count;
            
            initial
            begin
                count = 'b0;
            end
            
            always @(posedge Origin_Clock or posedge reset)
            begin
                if (reset)
                    count <= 'd0;  		
                else 
                begin
                    if(count >= 'd131072)
                        count <= 'd0;
                    else
                        count <= count + 'd1;
                end
            end
            
            assign	pulse = count[16 : 14];
            
        endmodule
        ```
    6. **<font face="concolas">Hex7SegmentDisplay.v</font>**  
        ```verilog {.line-numbers}
        module Hex7SegmentDisplay(x, seg);
            input  [3:0] x;
            output [6:0] seg; 
        //                   0                                 1                                 2                                 3                                 4                                 5                                 6                                 7                                 8                                 9                                 A                                 b                                 C                                 d                                 E                                 F
        //	assign AbCdEF = (~x[3] & ~x[2] & ~x[1] & ~x[0]) | (~x[3] & ~x[2] & ~x[1] &  x[0]) | (~x[3] & ~x[2] &  x[1] & ~x[0]) | (~x[3] & ~x[2] &  x[1] &  x[0]) | (~x[3] &  x[2] & ~x[1] & ~x[0]) | (~x[3] &  x[2] & ~x[1] &  x[0]) | (~x[3] &  x[2] &  x[1] & ~x[0]) | (~x[3] &  x[2] &  x[1] &  x[0]) | ( x[3] & ~x[2] & ~x[1] & ~x[0]) | ( x[3] & ~x[2] & ~x[1] &  x[0]) | ( x[3] & ~x[2] &  x[1] & ~x[0]) | ( x[3] & ~x[2] &  x[1] &  x[0]) | ( x[3] &  x[2] & ~x[1] & ~x[0]) | ( x[3] &  x[2] & ~x[1] &  x[0]) | ( x[3] &  x[2] &  x[1] & ~x[0]) | ( x[3] &  x[2] &  x[1] &  x[0]);
            assign seg[0] =                                   (~x[3] & ~x[2] & ~x[1] &  x[0]) |                                                                                                                                                                                                                                                                                                                   ( x[3] & ~x[2] &  x[1] &  x[0]) |                                   ( x[3] &  x[2] & ~x[1] &  x[0])                                                                    ;
            assign seg[1] =                                                                                                                                                                           (~x[3] &  x[2] & ~x[1] &  x[0]) | (~x[3] &  x[2] &  x[1] & ~x[0]) |                                                                                                                                         ( x[3] & ~x[2] &  x[1] &  x[0]) | ( x[3] &  x[2] & ~x[1] & ~x[0]) |                                   ( x[3] &  x[2] &  x[1] & ~x[0]) | ( x[3] &  x[2] &  x[1] &  x[0]);
            assign seg[2] =                                                                     (~x[3] & ~x[2] &  x[1] & ~x[0]) |                                                                                                                                                                                                                                                                                                                   ( x[3] &  x[2] & ~x[1] & ~x[0]) |                                   ( x[3] &  x[2] &  x[1] & ~x[0]) | ( x[3] &  x[2] &  x[1] &  x[0]);
            assign seg[3] =                                   (~x[3] & ~x[2] & ~x[1] &  x[0]) |                                                                     (~x[3] &  x[2] & ~x[1] & ~x[0]) |                                                                     (~x[3] &  x[2] &  x[1] &  x[0]) |                                   ( x[3] & ~x[2] & ~x[1] &  x[0]) | ( x[3] & ~x[2] &  x[1] & ~x[0]) |                                                                                                                                         ( x[3] &  x[2] &  x[1] &  x[0]);
            assign seg[4] =                                   (~x[3] & ~x[2] & ~x[1] &  x[0]) |                                   (~x[3] & ~x[2] &  x[1] &  x[0]) | (~x[3] &  x[2] & ~x[1] & ~x[0]) | (~x[3] &  x[2] & ~x[1] &  x[0]) |                                   (~x[3] &  x[2] &  x[1] &  x[0]) |                                   ( x[3] & ~x[2] & ~x[1] &  x[0])                                                                                                                                                                                                            ;
            assign seg[5] =                                   (~x[3] & ~x[2] & ~x[1] &  x[0]) | (~x[3] & ~x[2] &  x[1] & ~x[0]) | (~x[3] & ~x[2] &  x[1] &  x[0]) |                                                                                                       (~x[3] &  x[2] &  x[1] &  x[0]) |                                                                                                                                                                           ( x[3] &  x[2] & ~x[1] &  x[0])                                                                    ;
            assign seg[6] = (~x[3] & ~x[2] & ~x[1] & ~x[0]) | (~x[3] & ~x[2] & ~x[1] &  x[0]) |                                                                                                                                                                           (~x[3] &  x[2] &  x[1] &  x[0]) |                                                                                                                                         ( x[3] &  x[2] & ~x[1] & ~x[0])                                                                                                      ;  
        endmodule
        ```
- **原理逻辑电路图**  
    ![DDU+CPU原理](https://github.com/lyc0930/COD/blob/master/MulticycleCPU/CPUMEMDDU_RTL.png?raw=true)  
    **逻辑设计说明：**  
    >&emsp;&emsp;&emsp;&emsp;通过例化`Clock Wizard`IP核以及实例化时钟分频模块`FrequencyDivision`为CPU提供执行时钟，`SinglePulse`模块用于在接受到`step`信号时生成单个时钟周期信号，`Debounce`模块用于下载时的按钮去抖动，通过`inc`与`dec`信号控制探针地址`ProbeAddress`，从CPU与Memory中探测到的数据以8位16进制数的形式显示在7段数码管上，当前探针地址与程序计数器PC中的值以LED形式显示。
- **下载照片**  
    ![CPU下载照片1](https://github.com/lyc0930/COD/blob/master/MulticycleCPU/IMG_20190516_182246.jpg?raw=true)  
    ![CPU下载照片2](https://github.com/lyc0930/COD/blob/master/MulticycleCPU/IMG_20190516_183104.jpg?raw=true)  
    ![CPU下载照片3](https://github.com/lyc0930/COD/blob/master/MulticycleCPU/IMG_20190516_184926.jpg?raw=true)  
    **下载照片说明：**
    >&emsp;&emsp;&emsp;&emsp;拨动`swt[15]`以执行复位后，在运行CPU之前，将`swt[1]`拨至开，按动`BTNU, BTND`调整`ProbeAddress`以观察存储器中各地址内的值，如图一所示，`led[15 : 8] = 'b00001011`表示在地址11下，存储器的值如7段数码管所示`'h200080003 = 'b00100000000010000000000000000011`，即指令`addi $t0,$0,3`;  
    >&emsp;&emsp;&emsp;&emsp;将`swt[0]`拨至开设置持续执行信号`continue`或按动`BTNC`输入`step`信号以执行单个时钟周期，在指令执行过程中，`led[7 : 0]`表示当前程序计数器输出的值的2～9位，即`PC[9 : 2]`，将`swt[1]`拨至关，按动`BTNU, BTND`调整`ProbeAddress`以观察寄存器中各地址内的值，如图二所示，`led[15 : 8] = 'b00010000`表示存储器`$s0`的值如7段数码管所示`'h00000008 = 'd8`，`led[7 : 0] = 'b00001111`表示`PC = 'b00000000000000000000000000111100`，这是执行指令`add  $s0,$t1,$t0`后的结果;  
    >&emsp;&emsp;&emsp;&emsp;CPU按给定指令序列执行至最终的成功分支`_success`，将`swt[1]`拨至开，按动`BTNU, BTND`调整`ProbeAddress = 'b00000010`以观察2号存储器中值，如图三所示，2号存储器的值如7段数码管所示`'h00000001 = 'd1`，即程序已进入成功分支  
</br> 
## 实验总结
<p>&emsp;&emsp;本次实验通过总结例化本学期学习编写的寄存器堆、ALU等模块，相对完整的以多周期实现了一个能执行一定MIPS指令的CPU，并编写了调试与显示模块对其运行与功能加以测试。本次实验的综合性较强，不仅加深了对于CPU多周期执行中控制信号的产生、功能单元的连接等方面的理解，也从多个角度提高了自身对于计算机指令执行的效率的认识。相对较高的代码量和程序文件数量也锻炼了模块化开发与项目文件组织的能力，强化了硬件语言开发过程中的可扩展性和规范意识。</p>  

## 附
&emsp;&emsp;本报告中出现的所有设计与测试源代码文件以及相关截图与照片可见  
&emsp;&emsp;[GitHub@lyc0930](https://github.com/lyc0930/COD)